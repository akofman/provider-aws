// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package convert

import (
	types "github.com/aws/aws-sdk-go-v2/service/elasticache/types"
	"time"
)

type ConverterImpl struct{}

func (c *ConverterImpl) DeepCopyAWSCacheCluster(source *types.CacheCluster) *types.CacheCluster {
	var pTypesCacheCluster *types.CacheCluster
	if source != nil {
		var typesCacheCluster types.CacheCluster
		if (*source).ARN != nil {
			xstring := *(*source).ARN
			typesCacheCluster.ARN = &xstring
		}
		if (*source).AtRestEncryptionEnabled != nil {
			xbool := *(*source).AtRestEncryptionEnabled
			typesCacheCluster.AtRestEncryptionEnabled = &xbool
		}
		if (*source).AuthTokenEnabled != nil {
			xbool2 := *(*source).AuthTokenEnabled
			typesCacheCluster.AuthTokenEnabled = &xbool2
		}
		typesCacheCluster.AuthTokenLastModifiedDate = c.pTimeTimeToPTimeTime((*source).AuthTokenLastModifiedDate)
		if (*source).AutoMinorVersionUpgrade != nil {
			xbool3 := *(*source).AutoMinorVersionUpgrade
			typesCacheCluster.AutoMinorVersionUpgrade = &xbool3
		}
		typesCacheCluster.CacheClusterCreateTime = c.pTimeTimeToPTimeTime((*source).CacheClusterCreateTime)
		if (*source).CacheClusterId != nil {
			xstring2 := *(*source).CacheClusterId
			typesCacheCluster.CacheClusterId = &xstring2
		}
		if (*source).CacheClusterStatus != nil {
			xstring3 := *(*source).CacheClusterStatus
			typesCacheCluster.CacheClusterStatus = &xstring3
		}
		if (*source).CacheNodeType != nil {
			xstring4 := *(*source).CacheNodeType
			typesCacheCluster.CacheNodeType = &xstring4
		}
		if (*source).CacheNodes != nil {
			typesCacheCluster.CacheNodes = make([]types.CacheNode, len((*source).CacheNodes))
			for i := 0; i < len((*source).CacheNodes); i++ {
				typesCacheCluster.CacheNodes[i] = c.typesCacheNodeToTypesCacheNode((*source).CacheNodes[i])
			}
		}
		typesCacheCluster.CacheParameterGroup = c.pTypesCacheParameterGroupStatusToPTypesCacheParameterGroupStatus((*source).CacheParameterGroup)
		if (*source).CacheSecurityGroups != nil {
			typesCacheCluster.CacheSecurityGroups = make([]types.CacheSecurityGroupMembership, len((*source).CacheSecurityGroups))
			for j := 0; j < len((*source).CacheSecurityGroups); j++ {
				typesCacheCluster.CacheSecurityGroups[j] = c.typesCacheSecurityGroupMembershipToTypesCacheSecurityGroupMembership((*source).CacheSecurityGroups[j])
			}
		}
		if (*source).CacheSubnetGroupName != nil {
			xstring5 := *(*source).CacheSubnetGroupName
			typesCacheCluster.CacheSubnetGroupName = &xstring5
		}
		if (*source).ClientDownloadLandingPage != nil {
			xstring6 := *(*source).ClientDownloadLandingPage
			typesCacheCluster.ClientDownloadLandingPage = &xstring6
		}
		typesCacheCluster.ConfigurationEndpoint = c.pTypesEndpointToPTypesEndpoint((*source).ConfigurationEndpoint)
		if (*source).Engine != nil {
			xstring7 := *(*source).Engine
			typesCacheCluster.Engine = &xstring7
		}
		if (*source).EngineVersion != nil {
			xstring8 := *(*source).EngineVersion
			typesCacheCluster.EngineVersion = &xstring8
		}
		typesCacheCluster.IpDiscovery = types.IpDiscovery((*source).IpDiscovery)
		if (*source).LogDeliveryConfigurations != nil {
			typesCacheCluster.LogDeliveryConfigurations = make([]types.LogDeliveryConfiguration, len((*source).LogDeliveryConfigurations))
			for k := 0; k < len((*source).LogDeliveryConfigurations); k++ {
				typesCacheCluster.LogDeliveryConfigurations[k] = c.typesLogDeliveryConfigurationToTypesLogDeliveryConfiguration((*source).LogDeliveryConfigurations[k])
			}
		}
		typesCacheCluster.NetworkType = types.NetworkType((*source).NetworkType)
		typesCacheCluster.NotificationConfiguration = c.pTypesNotificationConfigurationToPTypesNotificationConfiguration((*source).NotificationConfiguration)
		if (*source).NumCacheNodes != nil {
			xint32 := *(*source).NumCacheNodes
			typesCacheCluster.NumCacheNodes = &xint32
		}
		typesCacheCluster.PendingModifiedValues = c.pTypesPendingModifiedValuesToPTypesPendingModifiedValues((*source).PendingModifiedValues)
		if (*source).PreferredAvailabilityZone != nil {
			xstring9 := *(*source).PreferredAvailabilityZone
			typesCacheCluster.PreferredAvailabilityZone = &xstring9
		}
		if (*source).PreferredMaintenanceWindow != nil {
			xstring10 := *(*source).PreferredMaintenanceWindow
			typesCacheCluster.PreferredMaintenanceWindow = &xstring10
		}
		if (*source).PreferredOutpostArn != nil {
			xstring11 := *(*source).PreferredOutpostArn
			typesCacheCluster.PreferredOutpostArn = &xstring11
		}
		if (*source).ReplicationGroupId != nil {
			xstring12 := *(*source).ReplicationGroupId
			typesCacheCluster.ReplicationGroupId = &xstring12
		}
		if (*source).ReplicationGroupLogDeliveryEnabled != nil {
			xbool4 := *(*source).ReplicationGroupLogDeliveryEnabled
			typesCacheCluster.ReplicationGroupLogDeliveryEnabled = &xbool4
		}
		if (*source).SecurityGroups != nil {
			typesCacheCluster.SecurityGroups = make([]types.SecurityGroupMembership, len((*source).SecurityGroups))
			for l := 0; l < len((*source).SecurityGroups); l++ {
				typesCacheCluster.SecurityGroups[l] = c.typesSecurityGroupMembershipToTypesSecurityGroupMembership((*source).SecurityGroups[l])
			}
		}
		if (*source).SnapshotRetentionLimit != nil {
			xint322 := *(*source).SnapshotRetentionLimit
			typesCacheCluster.SnapshotRetentionLimit = &xint322
		}
		if (*source).SnapshotWindow != nil {
			xstring13 := *(*source).SnapshotWindow
			typesCacheCluster.SnapshotWindow = &xstring13
		}
		if (*source).TransitEncryptionEnabled != nil {
			xbool5 := *(*source).TransitEncryptionEnabled
			typesCacheCluster.TransitEncryptionEnabled = &xbool5
		}
		typesCacheCluster.TransitEncryptionMode = types.TransitEncryptionMode((*source).TransitEncryptionMode)
		pTypesCacheCluster = &typesCacheCluster
	}
	return pTypesCacheCluster
}
func (c *ConverterImpl) pTimeTimeToPTimeTime(source *time.Time) *time.Time {
	var pTimeTime *time.Time
	if source != nil {
		var timeTime time.Time
		_ = (*source)
		pTimeTime = &timeTime
	}
	return pTimeTime
}
func (c *ConverterImpl) pTypesCacheParameterGroupStatusToPTypesCacheParameterGroupStatus(source *types.CacheParameterGroupStatus) *types.CacheParameterGroupStatus {
	var pTypesCacheParameterGroupStatus *types.CacheParameterGroupStatus
	if source != nil {
		var typesCacheParameterGroupStatus types.CacheParameterGroupStatus
		if (*source).CacheNodeIdsToReboot != nil {
			typesCacheParameterGroupStatus.CacheNodeIdsToReboot = make([]string, len((*source).CacheNodeIdsToReboot))
			for i := 0; i < len((*source).CacheNodeIdsToReboot); i++ {
				typesCacheParameterGroupStatus.CacheNodeIdsToReboot[i] = (*source).CacheNodeIdsToReboot[i]
			}
		}
		if (*source).CacheParameterGroupName != nil {
			xstring := *(*source).CacheParameterGroupName
			typesCacheParameterGroupStatus.CacheParameterGroupName = &xstring
		}
		if (*source).ParameterApplyStatus != nil {
			xstring2 := *(*source).ParameterApplyStatus
			typesCacheParameterGroupStatus.ParameterApplyStatus = &xstring2
		}
		pTypesCacheParameterGroupStatus = &typesCacheParameterGroupStatus
	}
	return pTypesCacheParameterGroupStatus
}
func (c *ConverterImpl) pTypesCloudWatchLogsDestinationDetailsToPTypesCloudWatchLogsDestinationDetails(source *types.CloudWatchLogsDestinationDetails) *types.CloudWatchLogsDestinationDetails {
	var pTypesCloudWatchLogsDestinationDetails *types.CloudWatchLogsDestinationDetails
	if source != nil {
		var typesCloudWatchLogsDestinationDetails types.CloudWatchLogsDestinationDetails
		if (*source).LogGroup != nil {
			xstring := *(*source).LogGroup
			typesCloudWatchLogsDestinationDetails.LogGroup = &xstring
		}
		pTypesCloudWatchLogsDestinationDetails = &typesCloudWatchLogsDestinationDetails
	}
	return pTypesCloudWatchLogsDestinationDetails
}
func (c *ConverterImpl) pTypesDestinationDetailsToPTypesDestinationDetails(source *types.DestinationDetails) *types.DestinationDetails {
	var pTypesDestinationDetails *types.DestinationDetails
	if source != nil {
		var typesDestinationDetails types.DestinationDetails
		typesDestinationDetails.CloudWatchLogsDetails = c.pTypesCloudWatchLogsDestinationDetailsToPTypesCloudWatchLogsDestinationDetails((*source).CloudWatchLogsDetails)
		typesDestinationDetails.KinesisFirehoseDetails = c.pTypesKinesisFirehoseDestinationDetailsToPTypesKinesisFirehoseDestinationDetails((*source).KinesisFirehoseDetails)
		pTypesDestinationDetails = &typesDestinationDetails
	}
	return pTypesDestinationDetails
}
func (c *ConverterImpl) pTypesEndpointToPTypesEndpoint(source *types.Endpoint) *types.Endpoint {
	var pTypesEndpoint *types.Endpoint
	if source != nil {
		var typesEndpoint types.Endpoint
		if (*source).Address != nil {
			xstring := *(*source).Address
			typesEndpoint.Address = &xstring
		}
		if (*source).Port != nil {
			xint32 := *(*source).Port
			typesEndpoint.Port = &xint32
		}
		pTypesEndpoint = &typesEndpoint
	}
	return pTypesEndpoint
}
func (c *ConverterImpl) pTypesKinesisFirehoseDestinationDetailsToPTypesKinesisFirehoseDestinationDetails(source *types.KinesisFirehoseDestinationDetails) *types.KinesisFirehoseDestinationDetails {
	var pTypesKinesisFirehoseDestinationDetails *types.KinesisFirehoseDestinationDetails
	if source != nil {
		var typesKinesisFirehoseDestinationDetails types.KinesisFirehoseDestinationDetails
		if (*source).DeliveryStream != nil {
			xstring := *(*source).DeliveryStream
			typesKinesisFirehoseDestinationDetails.DeliveryStream = &xstring
		}
		pTypesKinesisFirehoseDestinationDetails = &typesKinesisFirehoseDestinationDetails
	}
	return pTypesKinesisFirehoseDestinationDetails
}
func (c *ConverterImpl) pTypesNotificationConfigurationToPTypesNotificationConfiguration(source *types.NotificationConfiguration) *types.NotificationConfiguration {
	var pTypesNotificationConfiguration *types.NotificationConfiguration
	if source != nil {
		var typesNotificationConfiguration types.NotificationConfiguration
		if (*source).TopicArn != nil {
			xstring := *(*source).TopicArn
			typesNotificationConfiguration.TopicArn = &xstring
		}
		if (*source).TopicStatus != nil {
			xstring2 := *(*source).TopicStatus
			typesNotificationConfiguration.TopicStatus = &xstring2
		}
		pTypesNotificationConfiguration = &typesNotificationConfiguration
	}
	return pTypesNotificationConfiguration
}
func (c *ConverterImpl) pTypesPendingModifiedValuesToPTypesPendingModifiedValues(source *types.PendingModifiedValues) *types.PendingModifiedValues {
	var pTypesPendingModifiedValues *types.PendingModifiedValues
	if source != nil {
		var typesPendingModifiedValues types.PendingModifiedValues
		typesPendingModifiedValues.AuthTokenStatus = types.AuthTokenUpdateStatus((*source).AuthTokenStatus)
		if (*source).CacheNodeIdsToRemove != nil {
			typesPendingModifiedValues.CacheNodeIdsToRemove = make([]string, len((*source).CacheNodeIdsToRemove))
			for i := 0; i < len((*source).CacheNodeIdsToRemove); i++ {
				typesPendingModifiedValues.CacheNodeIdsToRemove[i] = (*source).CacheNodeIdsToRemove[i]
			}
		}
		if (*source).CacheNodeType != nil {
			xstring := *(*source).CacheNodeType
			typesPendingModifiedValues.CacheNodeType = &xstring
		}
		if (*source).EngineVersion != nil {
			xstring2 := *(*source).EngineVersion
			typesPendingModifiedValues.EngineVersion = &xstring2
		}
		if (*source).LogDeliveryConfigurations != nil {
			typesPendingModifiedValues.LogDeliveryConfigurations = make([]types.PendingLogDeliveryConfiguration, len((*source).LogDeliveryConfigurations))
			for j := 0; j < len((*source).LogDeliveryConfigurations); j++ {
				typesPendingModifiedValues.LogDeliveryConfigurations[j] = c.typesPendingLogDeliveryConfigurationToTypesPendingLogDeliveryConfiguration((*source).LogDeliveryConfigurations[j])
			}
		}
		if (*source).NumCacheNodes != nil {
			xint32 := *(*source).NumCacheNodes
			typesPendingModifiedValues.NumCacheNodes = &xint32
		}
		if (*source).TransitEncryptionEnabled != nil {
			xbool := *(*source).TransitEncryptionEnabled
			typesPendingModifiedValues.TransitEncryptionEnabled = &xbool
		}
		typesPendingModifiedValues.TransitEncryptionMode = types.TransitEncryptionMode((*source).TransitEncryptionMode)
		pTypesPendingModifiedValues = &typesPendingModifiedValues
	}
	return pTypesPendingModifiedValues
}
func (c *ConverterImpl) typesCacheNodeToTypesCacheNode(source types.CacheNode) types.CacheNode {
	var typesCacheNode types.CacheNode
	typesCacheNode.CacheNodeCreateTime = c.pTimeTimeToPTimeTime(source.CacheNodeCreateTime)
	if source.CacheNodeId != nil {
		xstring := *source.CacheNodeId
		typesCacheNode.CacheNodeId = &xstring
	}
	if source.CacheNodeStatus != nil {
		xstring2 := *source.CacheNodeStatus
		typesCacheNode.CacheNodeStatus = &xstring2
	}
	if source.CustomerAvailabilityZone != nil {
		xstring3 := *source.CustomerAvailabilityZone
		typesCacheNode.CustomerAvailabilityZone = &xstring3
	}
	if source.CustomerOutpostArn != nil {
		xstring4 := *source.CustomerOutpostArn
		typesCacheNode.CustomerOutpostArn = &xstring4
	}
	typesCacheNode.Endpoint = c.pTypesEndpointToPTypesEndpoint(source.Endpoint)
	if source.ParameterGroupStatus != nil {
		xstring5 := *source.ParameterGroupStatus
		typesCacheNode.ParameterGroupStatus = &xstring5
	}
	if source.SourceCacheNodeId != nil {
		xstring6 := *source.SourceCacheNodeId
		typesCacheNode.SourceCacheNodeId = &xstring6
	}
	return typesCacheNode
}
func (c *ConverterImpl) typesCacheSecurityGroupMembershipToTypesCacheSecurityGroupMembership(source types.CacheSecurityGroupMembership) types.CacheSecurityGroupMembership {
	var typesCacheSecurityGroupMembership types.CacheSecurityGroupMembership
	if source.CacheSecurityGroupName != nil {
		xstring := *source.CacheSecurityGroupName
		typesCacheSecurityGroupMembership.CacheSecurityGroupName = &xstring
	}
	if source.Status != nil {
		xstring2 := *source.Status
		typesCacheSecurityGroupMembership.Status = &xstring2
	}
	return typesCacheSecurityGroupMembership
}
func (c *ConverterImpl) typesLogDeliveryConfigurationToTypesLogDeliveryConfiguration(source types.LogDeliveryConfiguration) types.LogDeliveryConfiguration {
	var typesLogDeliveryConfiguration types.LogDeliveryConfiguration
	typesLogDeliveryConfiguration.DestinationDetails = c.pTypesDestinationDetailsToPTypesDestinationDetails(source.DestinationDetails)
	typesLogDeliveryConfiguration.DestinationType = types.DestinationType(source.DestinationType)
	typesLogDeliveryConfiguration.LogFormat = types.LogFormat(source.LogFormat)
	typesLogDeliveryConfiguration.LogType = types.LogType(source.LogType)
	if source.Message != nil {
		xstring := *source.Message
		typesLogDeliveryConfiguration.Message = &xstring
	}
	typesLogDeliveryConfiguration.Status = types.LogDeliveryConfigurationStatus(source.Status)
	return typesLogDeliveryConfiguration
}
func (c *ConverterImpl) typesPendingLogDeliveryConfigurationToTypesPendingLogDeliveryConfiguration(source types.PendingLogDeliveryConfiguration) types.PendingLogDeliveryConfiguration {
	var typesPendingLogDeliveryConfiguration types.PendingLogDeliveryConfiguration
	typesPendingLogDeliveryConfiguration.DestinationDetails = c.pTypesDestinationDetailsToPTypesDestinationDetails(source.DestinationDetails)
	typesPendingLogDeliveryConfiguration.DestinationType = types.DestinationType(source.DestinationType)
	typesPendingLogDeliveryConfiguration.LogFormat = types.LogFormat(source.LogFormat)
	typesPendingLogDeliveryConfiguration.LogType = types.LogType(source.LogType)
	return typesPendingLogDeliveryConfiguration
}
func (c *ConverterImpl) typesSecurityGroupMembershipToTypesSecurityGroupMembership(source types.SecurityGroupMembership) types.SecurityGroupMembership {
	var typesSecurityGroupMembership types.SecurityGroupMembership
	if source.SecurityGroupId != nil {
		xstring := *source.SecurityGroupId
		typesSecurityGroupMembership.SecurityGroupId = &xstring
	}
	if source.Status != nil {
		xstring2 := *source.Status
		typesSecurityGroupMembership.Status = &xstring2
	}
	return typesSecurityGroupMembership
}
