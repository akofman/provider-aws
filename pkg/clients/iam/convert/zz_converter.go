// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package convert

import (
	types "github.com/aws/aws-sdk-go-v2/service/iam/types"
	"time"
)

type ConverterImpl struct{}

func (c *ConverterImpl) DeepCopyAWSRole(source *types.Role) *types.Role {
	var pTypesRole *types.Role
	if source != nil {
		var typesRole types.Role
		if (*source).Arn != nil {
			xstring := *(*source).Arn
			typesRole.Arn = &xstring
		}
		typesRole.CreateDate = c.pTimeTimeToPTimeTime((*source).CreateDate)
		if (*source).Path != nil {
			xstring2 := *(*source).Path
			typesRole.Path = &xstring2
		}
		if (*source).RoleId != nil {
			xstring3 := *(*source).RoleId
			typesRole.RoleId = &xstring3
		}
		if (*source).RoleName != nil {
			xstring4 := *(*source).RoleName
			typesRole.RoleName = &xstring4
		}
		if (*source).AssumeRolePolicyDocument != nil {
			xstring5 := *(*source).AssumeRolePolicyDocument
			typesRole.AssumeRolePolicyDocument = &xstring5
		}
		if (*source).Description != nil {
			xstring6 := *(*source).Description
			typesRole.Description = &xstring6
		}
		if (*source).MaxSessionDuration != nil {
			xint32 := *(*source).MaxSessionDuration
			typesRole.MaxSessionDuration = &xint32
		}
		typesRole.PermissionsBoundary = c.pTypesAttachedPermissionsBoundaryToPTypesAttachedPermissionsBoundary((*source).PermissionsBoundary)
		typesRole.RoleLastUsed = c.pTypesRoleLastUsedToPTypesRoleLastUsed((*source).RoleLastUsed)
		if (*source).Tags != nil {
			typesRole.Tags = make([]types.Tag, len((*source).Tags))
			for i := 0; i < len((*source).Tags); i++ {
				typesRole.Tags[i] = c.typesTagToTypesTag((*source).Tags[i])
			}
		}
		pTypesRole = &typesRole
	}
	return pTypesRole
}
func (c *ConverterImpl) pTimeTimeToPTimeTime(source *time.Time) *time.Time {
	var pTimeTime *time.Time
	if source != nil {
		var timeTime time.Time
		_ = (*source)
		pTimeTime = &timeTime
	}
	return pTimeTime
}
func (c *ConverterImpl) pTypesAttachedPermissionsBoundaryToPTypesAttachedPermissionsBoundary(source *types.AttachedPermissionsBoundary) *types.AttachedPermissionsBoundary {
	var pTypesAttachedPermissionsBoundary *types.AttachedPermissionsBoundary
	if source != nil {
		var typesAttachedPermissionsBoundary types.AttachedPermissionsBoundary
		if (*source).PermissionsBoundaryArn != nil {
			xstring := *(*source).PermissionsBoundaryArn
			typesAttachedPermissionsBoundary.PermissionsBoundaryArn = &xstring
		}
		typesAttachedPermissionsBoundary.PermissionsBoundaryType = types.PermissionsBoundaryAttachmentType((*source).PermissionsBoundaryType)
		pTypesAttachedPermissionsBoundary = &typesAttachedPermissionsBoundary
	}
	return pTypesAttachedPermissionsBoundary
}
func (c *ConverterImpl) pTypesRoleLastUsedToPTypesRoleLastUsed(source *types.RoleLastUsed) *types.RoleLastUsed {
	var pTypesRoleLastUsed *types.RoleLastUsed
	if source != nil {
		var typesRoleLastUsed types.RoleLastUsed
		typesRoleLastUsed.LastUsedDate = c.pTimeTimeToPTimeTime((*source).LastUsedDate)
		if (*source).Region != nil {
			xstring := *(*source).Region
			typesRoleLastUsed.Region = &xstring
		}
		pTypesRoleLastUsed = &typesRoleLastUsed
	}
	return pTypesRoleLastUsed
}
func (c *ConverterImpl) typesTagToTypesTag(source types.Tag) types.Tag {
	var typesTag types.Tag
	if source.Key != nil {
		xstring := *source.Key
		typesTag.Key = &xstring
	}
	if source.Value != nil {
		xstring2 := *source.Value
		typesTag.Value = &xstring2
	}
	return typesTag
}
